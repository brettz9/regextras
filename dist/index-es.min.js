function mixinRegex(e,t,n=e.lastIndex){return t=t||"",(e=new RegExp(e.source,(t.includes("g")?"g":e.global?"g":"")+(t.includes("i")?"i":e.ignoreCase?"i":"")+(t.includes("m")?"m":e.multiline?"m":"")+(t.includes("u")?"u":e.sticky?"u":"")+(t.includes("y")?"y":e.sticky?"y":""))).lastIndex=n,e}class RegExtras{constructor(e,t,n){this.regex=mixinRegex("string"==typeof e?new RegExp(e):mixinRegex(e),t||"",n)}forEach(e,t,n=null){const l=mixinRegex(this.regex,"g");let i,r,c=0;for(;null!==(i=l.exec(e));)r=i.splice(0,1),t.apply(n,i.concat(c++,r));return this}some(e,t,n=null){const l=mixinRegex(this.regex,"g");let i,r,c,x=0;for(;null!==(i=l.exec(e));)if(c=i.splice(0,1),r=t.apply(n,i.concat(x++,c)))return!0;return!1}every(e,t,n=null){const l=mixinRegex(this.regex,"g");let i,r,c,x=0;for(;null!==(i=l.exec(e));)if(c=i.splice(0,1),!(r=t.apply(n,i.concat(x++,c))))return!1;return!0}map(e,t,n=null){const l=[],i=mixinRegex(this.regex,"g");let r,c,x=0;for(;null!==(r=i.exec(e));)c=r.splice(0,1),l.push(t.apply(n,r.concat(x++,c)));return l}filter(e,t,n=null){let l,i,r=0;const c=[],x=mixinRegex(this.regex,"g");for(;null!==(l=x.exec(e));)i=l.splice(0,1),l=l.concat(r++,i),t.apply(n,l)&&c.push(i[0]);return c}reduce(e,t,n,l=null){let i,r,c=0;const x=mixinRegex(this.regex,"g");for(n||null!==(i=x.exec(e))&&(r=i.splice(0,1),n=t.apply(l,[""].concat(i.concat(c++,r))));null!==(i=x.exec(e));)r=i.splice(0,1),n=t.apply(l,[n].concat(i.concat(c++,r)));return n}reduceRight(e,t,n,l){let i,r,c,x=l,s=n;const o=[],u=mixinRegex(this.regex,"g");for(x=x||null;null!==(i=u.exec(e));)o.push(i);if(!(c=o.length)){if(arguments.length<3)throw new TypeError("reduce of empty matches array with no initial value");return s}return s||(i=o.splice(-1)[0],r=i.splice(0,1),s=t.apply(x,[""].concat(i.concat(c--,r)))),o.reduceRight((e,n)=>(r=n.splice(0,1),s=t.apply(x,[s].concat(n.concat(c--,r))),e),o),s}find(e,t,n=null){let l,i,r,c=0;const x=mixinRegex(this.regex,"g");for(;null!==(l=x.exec(e));)if(r=l.splice(0,1),i=t.apply(n,l.concat(c++,r)))return r[0];return!1}findIndex(e,t,n=null){const l=mixinRegex(this.regex,"g");let i,r=0;for(;null!==(i=l.exec(e));){const e=i.splice(0,1);if(t.apply(n,i.concat(r++,e)))return r-1}return-1}findExec(e,t,n=null){const l=mixinRegex(this.regex,"g");let i,r=0;for(;null!==(i=l.exec(e));){const e=i.splice(0,1);if(t.apply(n,i.concat(r++,e)))return i}return!1}filterExec(e,t,n=null){let l,i,r=0;const c=[],x=mixinRegex(this.regex,"g");for(;null!==(l=x.exec(e));)i=l.splice(0,1),l.push(r++,i[0]),t.apply(n,l)&&c.push(l);return c}}const _RegExtras=RegExtras;function addPrototypeMethods(e){e.prototype.entries=function*(t){let n,l=0;const i=e.mixinRegex(this.regex,"g");for(;null!==(n=i.exec(t));)yield[l++,n]},e.prototype.values=function*(t){let n;const l=e.mixinRegex(this.regex,"g");for(;null!==(n=l.exec(t));)yield n},e.prototype.keys=function*(t){let n=0;const l=e.mixinRegex(this.regex,"g");for(;null!==l.exec(t);)yield n++}}(RegExtras=function(...e){return new _RegExtras(...e)}).prototype=_RegExtras.prototype,RegExtras.mixinRegex=mixinRegex,addPrototypeMethods(RegExtras);export{mixinRegex,RegExtras};
